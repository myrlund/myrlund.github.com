<!DOCTYPE html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>64-bit integers in Javascript Â· myrlund.no</title><meta name=viewport content="width=device-width"><link rel=stylesheet href=/css/53aa.main.css></head><body><div class=container><div class=site><header id=header><h1><a href=/>Jonas Myrlund</a> <small>Words in a huge cloud</small></h1></header><section class=content><article class=post><header><h2><a href=/2012/07/28/64-bit-ints-in-javascript.html>64-bit integers in Javascript</a></h2><aside class=meta><time datetime=2012-07-28T00:00:00+02:00><span class=year>2012</span> July 28</time><div class=tags><i class=icon-tags></i><ul><li>javascript</li><li>wat</li></ul></div></aside></header><section class=content><p>A couple of weeks ago, upon implementing a web socket protocol using JSON-encoded messages, we ran into quite the problem.</p><p>Server side, various ids and generation numbers were stored as 64-bit integers. But alas, as it turns out, Javascript doesn&#39;t support 64-bit integers... At all. It doesn&#39;t even whine. Any number exceeding 9007199254740992 will silently be padded with zeros... No wonder we didn&#39;t get the expected results in our interactions with the server.</p><p><em>In case you&#39;re one of those people: Javascript&#39;s numbers are represented using 64-bit floating points with double precision, and hence the integers can&#39;t exceed 2<sup>53</sup>. Consult the <a href=http://ecma262-5.com/ELS5_HTML.htm#Section_8.5>ECMAscript language specification</a> for more information.</em></p><p>Anyways, back to the story. With the protocol well in production on other platforms, it wasn&#39;t likely to change, so <em>a hairy fix was needed</em>.</p><p>Luckily, the encoded JSON strings arrive over web sockets as just that: strings. Problem is, the moment one tries to <code>JSON.parse(jsonString)</code> it&#39;s already too late -- information is lost.</p><h2>Regex to the rescue</h2><p>Our <del>temporary</del> solution consisted of three parts:</p><ol><li>running a simple regex over the incoming strings before parsing them</li><li>running a similar regex over the outgoing strings after serializing them</li><li>using string representations of the int64 fields internally</li></ol><p>The incoming messages we handled like so:</p><div class=highlight><pre><code class=javascript><span class=kd>var</span> <span class=nx>jsonString</span> <span class=o>=</span> <span class=s1>&#39;{&quot;foo&quot;: 123456789123456789, &quot;bar&quot;: 987654321987654321}&#39;</span>
<span class=kd>var</span> <span class=nx>numbers</span> <span class=o>=</span> <span class=sr>/(&quot;[^&quot;]*&quot;:\s*)(\d{15,})([,}])/g</span>
<span class=nx>jsonString</span> <span class=o>=</span> <span class=nx>jsonString</span><span class=p>.</span><span class=nx>replace</span><span class=p>(</span><span class=nx>numbers</span><span class=p>,</span> <span class=s2>&quot;$1\&quot;$2\&quot;$3&quot;</span><span class=p>)</span>
<span class=nx>jsonString</span> <span class=c1>// =&gt; &#39;{&quot;foo&quot;: &quot;123456789123456789&quot;, &quot;bar&quot;: &quot;987654321987654321&quot;}&#39;</span>
</code></pre></div><p>...and the outgoing messages we handled like so:</p><div class=highlight><pre><code class=javascript><span class=kd>var</span> <span class=nx>jsonString</span> <span class=o>=</span> <span class=s1>&#39;{&quot;foo&quot;: &quot;123456789123456789&quot;, &quot;bar&quot;: &quot;987654321987654321&quot;}&#39;</span>
<span class=kd>var</span> <span class=nx>stringifiedNumbers</span> <span class=o>=</span> <span class=sr>/(&quot;[^&quot;]*&quot;:\s*)&quot;(\d{15,})&quot;([,}])/g</span>
<span class=nx>jsonString</span> <span class=o>=</span> <span class=nx>jsonString</span><span class=p>.</span><span class=nx>replace</span><span class=p>(</span><span class=nx>stringifiedNumbers</span><span class=p>,</span> <span class=s2>&quot;$1$2$3&quot;</span><span class=p>)</span>
<span class=nx>jsonString</span> <span class=c1>// =&gt; &#39;{&quot;foo&quot;: 123456789123456789, &quot;bar&quot;: 987654321987654321}&#39;</span>
</code></pre></div><h2>The moral of the story...</h2><ol><li>Unless absolutely necessary, avoid using numeric ids if they can be expected to become very large.</li><li>Regexes are awesome, although completely unreadable.</li></ol><p><strong>Do you have suggestions of better ways to handle this? Please let me know.</strong></p></section><footer class=slim-article-footer>By <a href=#footer>Jonas Myrlund</a></footer></article></section></div></div><!-- /container --><footer id=footer><div class=container><div class=site><div class=contact><p>Jonas Myrlund<br><a href=mailto:myrlund@gmail.com>myrlund@gmail.com</a></p></div><div class=contact><p><a href=http://github.com/myrlund/>github.com/myrlund</a><br><a href=http://twitter.com/danseku/>twitter.com/danseku</a><br></p></div></div></div></footer><script src=/js/d41d.scripts.js></script></body></html>